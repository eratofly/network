В рамках данной лабораторной работы реализован HTTP прокси-сервер с базовым механизмом кэширования. Цель кэширования — сократить время отклика для клиента и уменьшить нагрузку на сеть при повторных запросах к одним и тем же ресурсам.

Алгоритм работы
Логика кэширования реализована по принципу "Hash-based storage".

Идентификация ресурса:
При поступлении GET-запроса прокси выделяет полный URL (например, http://www.example.com/index.html). Этот URL является уникальным идентификатором ресурса.

Генерация ключа кэша:
Поскольку URL может содержать спецсимволы, недопустимые в именах файлов (/, :, ?), используется хеш-функция.
Filename = Hash(URL)
В реализации используется стандартная функция std::hash из C++, которая преобразует строку URL в уникальное числовое значение.

Проверка кэша:
Прокси проверяет наличие файла с полученным именем в директории ./cache/.

Cache Hit: Если файл существует, прокси считывает его содержимое и отправляет клиенту, не обращаясь к удаленному серверу.

Cache Miss: Если файла нет, прокси инициирует соединение с целевым веб-сервером.

Cache Store:
При получении данных от целевого сервера (Cache Miss) поток данных раздваивается:

Копия 1: Отправляется непосредственно клиенту (браузеру) в реальном времени.

Копия 2: Записывается в файл в директории ./cache/ с именем, полученным на шаге 2.

Особенности реализации

Игнорирование заголовков устаревания: В данной учебной реализации мы считаем кэш "вечным" для демонстрации скорости. В реальном продакшн-коде необходимо парсить заголовки Cache-Control и Expires.

HTTP/1.0: При запросе к внешнему серверу мы принудительно используем версию 1.0. Это упрощает работу, так как сервер закрывает соединение сразу после передачи файла (отсутствует сложный Chunked Transfer Encoding из HTTP/1.1), что позволяет легко определить конец файла.