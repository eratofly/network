Архитектура приложения
Приложение построено вокруг класса Webserver и использует модель один поток на соединение.

1. Класс Webserver
   Это ядро сервера, которое инкапсулирует всю логику:
Члены данных:
`m_serverSocket, m_socketAddress`: Низкоуровневые элементы для работы с сокетами.
`m_isStopping (std::atomic<bool>)`: Атомарный флаг, который используется для мягкого завершения работы сервера из обработчика сигналов (SIGINT). Это предотвращает зависание процесса.
`m_consoleMutex (std::mutex)`: Используется для синхронизации вывода в консоль (Log), чтобы избежать перемешивания логов от разных потоков.
2. Многопоточность и параллелизм
   Сервер использует std::thread для обработки каждого входящего HTTP-запроса.
Метод Webserver::Start() (основной поток) блокируется на accept(), ожидая нового клиента.
Как только клиент подключается, сервер создает новый поток:
`std::thread clientThread(&Webserver::HandleClient, this, clientSocket);
clientThread.detach();
clientThread.detach() позволяет рабочему потоку работать независимо от основного, не требуя его явного завершения (join).`

`Метод Webserver::HandleClient(int clientSocket) `выполняет всю работу по чтению, обработке и отправке ответа в этом новом потоке, обеспечивая параллельную обработку нескольких клиентов.

Рабочий цикл приложения
1. Инициализация (main.cpp и Webserver::StartServer)
   Настройка: В main.cpp создается экземпляр Webserver на порту 8080.

Обработка сигналов: Устанавливается обработчик сигнала SIGINT (Ctrl+C), который связывается с статическим методом Webserver::SignalHandler.

Сокет: Вызывается Webserver::StartServer(), который выполняет стандартные шаги настройки TCP-сокета: socket(), bind() (привязка к 0.0.0.0:8080) и listen() (перевод сокета в режим прослушивания).

2. Прием соединений (Webserver::Start)
   Основной поток входит в бесконечный цикл while (!m_isStopping).

Он блокируется на вызове accept(), ожидая входящего TCP-соединения.

При поступлении запроса, accept() возвращает новый файловый дескриптор (clientSocket).

Сервер немедленно создает новый поток (std::thread) для обслуживания этого клиента и возвращается к accept() для ожидания следующего.

3. Обработка запроса (Webserver::HandleClient)
   Каждый рабочий поток выполняет следующие шаги:

Чтение: Считывает данные из clientSocket (read()).

Парсинг: Извлекает запрошенный путь (fileName) с помощью ParseRequest.

Если путь /, возвращает index.html.

В противном случае, возвращает путь без начального слэша.

Логирование: Записывает в консоль информацию о запросе, включая ID текущего потока (используя m_consoleMutex для потокобезопасности).

Ответ:

Пытается открыть файл (std::ifstream file(fileName)).

Успех (200 OK): Если файл найден (file.good()), он считывает его содержимое, определяет MIME-тип (GetContentType) и отправляет HTTP-ответ с кодом 200.

Ошибка (404 Not Found): Если файл не найден, отправляет простой HTML-ответ с кодом 404.

Закрытие: Закрывает clientSocket (close()), освобождая ресурсы для этого соединения.

4. Корректное завершение работы (Сигнализация)
   При нажатии Ctrl+C (сигнал SIGINT), вызывается Webserver::SignalHandler.

Обработчик устанавливает m_isStopping = true.

Он вызывает shutdown(m_serverSocket, SHUT_RDWR), что немедленно разблокирует основной поток, застрявший на accept().

Основной цикл while (!m_isStopping) завершается.

При выходе из Webserver::Start(), деструктор ~Webserver() вызывает CloseServer(), закрывая главный сокет, и программа корректно завершает работу.